# Plan: PEP-723 Support for Eglot

## Overview

PEP-723 defines a standard for embedding metadata directly within single-file
Python scripts using a special comment block format:

```python
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "requests",
#   "rich",
# ]
# ///
```

This allows tools like `uv` to:

1. Detect dependencies from inline metadata
2. Create/manage an isolated virtual environment for the script
3. Run the script with all dependencies available

## Goal

Create an Emacs library `elisp/eglot-pep723.el` that:

1. Detects PEP-723 metadata in Python files
2. Sets the project root to the script's directory (so relative imports work)
3. Configures the LSP (ty or basedpyright) to use the correct Python interpreter
   from `uv python find --script`
4. Warns the user if the environment doesn't exist yet (without auto-installing)

## Key `uv` Commands

- **`uv python find --script <file>`** - Returns the Python interpreter path for
  the script
  - Returns system Python if environment not synced
  - Returns path in `~/.cache/uv/environments-v2/` if synced
- **`uv sync --script <file>`** - Creates/updates the script's virtual
  environment
- **`uv run <file>`** - Runs the script with dependencies

## LSP Configuration

### ty

Uses `eglot-workspace-configuration` with:

```elisp
(:ty (:configuration
      (:environment
       (:python "/path/to/python"
        :root ["/path/to/script/dir"]))))
```

### basedpyright

Uses `eglot-workspace-configuration` with:

```elisp
(:python (:pythonPath "/path/to/python")
 :basedpyright (:analysis (:extraPaths ["/path/to/script/dir"])))
```

---

## Files to Create

### `elisp/eglot-pep723.el`

A standalone library (~150 lines) with:

#### Customization

```elisp
(defgroup eglot-pep723 nil
  "PEP-723 support for Eglot."
  :group 'eglot
  :prefix "eglot-pep723-")

(defcustom eglot-pep723-lsp-server 'ty
  "LSP server to configure for PEP-723 scripts."
  :type '(choice (const :tag "ty" ty)
                 (const :tag "basedpyright" basedpyright))
  :group 'eglot-pep723)
```

#### Public API

```elisp
(defun eglot-pep723-has-metadata-p (&optional file)
  "Return non-nil if FILE contains PEP-723 script metadata.
If FILE is nil, use the current buffer's file.
Scans first 2KB for `# /// script' ... `# ///' block.")

(defun eglot-pep723-get-python-path (script-path)
  "Get Python interpreter path for SCRIPT-PATH using uv.
Runs `uv python find --script SCRIPT-PATH'.
Displays a warning if the environment needs to be synced.
Returns the Python path, or nil if uv is not available.")

;;;###autoload
(defun eglot-pep723-sync-environment ()
  "Sync the current PEP-723 script's environment, then restart Eglot.
Runs `uv sync --script' on the current file."
  (interactive))

;;;###autoload
(defun eglot-pep723-run-script ()
  "Run the current file as a PEP-723 script using `uv run'."
  (interactive))

;;;###autoload
(defun eglot-pep723-setup ()
  "Set up PEP-723 support for Python modes.
Adds hooks for project detection and Eglot configuration.
Call this after loading Eglot."
  (interactive))
```

#### Internal Functions

```elisp
(defun eglot-pep723--workspace-configuration (python-path script-dir)
  "Return workspace configuration plist for PYTHON-PATH and SCRIPT-DIR.
Format depends on `eglot-pep723-lsp-server'.")

(defun eglot-pep723--setup-buffer ()
  "Configure buffer-local Eglot settings for a PEP-723 script.")

(defun eglot-pep723--maybe-setup ()
  "Hook function: setup PEP-723 if current buffer has metadata.")

(defun eglot-pep723--project-find (dir)
  "Project detection for PEP-723 scripts.
Returns (pep723-script . SCRIPT-DIR) if current buffer is a PEP-723 script.")
```

#### Setup Function Implementation

```elisp
(defun eglot-pep723-setup ()
  "Set up PEP-723 support for Python modes."
  (interactive)
  ;; Add project detection
  (add-hook 'project-find-functions #'eglot-pep723--project-find)
  ;; Define project-root method for pep723-script projects
  (cl-defmethod project-root ((project (head pep723-script)))
    (cdr project))
  ;; Add hooks for Python modes (runs before any existing hooks)
  (add-hook 'python-mode-hook #'eglot-pep723--maybe-setup)
  (add-hook 'python-ts-mode-hook #'eglot-pep723--maybe-setup))
```

### `tmp/pep723-example.py`

Test script with PEP-723 metadata:

```python
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "requests",
#   "rich",
# ]
# ///

import requests
from rich.pretty import pprint

resp = requests.get("https://peps.python.org/api/peps.json")
data = resp.json()
pprint([(k, v["title"]) for k, v in data.items()][:10])
```

### `tmp/pep723-test.el`

Batch test harness (~60 lines):

```elisp
;;; tmp/pep723-test.el --- Test eglot-pep723 library -*- lexical-binding: t -*-

(add-to-list 'load-path (file-name-directory load-file-name))
(add-to-list 'load-path (expand-file-name "../elisp" (file-name-directory load-file-name)))

(require 'eglot-pep723)

(defvar my-pep723-test-dir (file-name-directory load-file-name))
(defvar my-pep723-test-script (expand-file-name "pep723-example.py" my-pep723-test-dir))

(defun my-pep723-run-tests ()
  "Run PEP-723 tests and report results."

  ;; Test 1: Detection with metadata
  (princ "Test 1: Detection (with metadata)... ")
  (if (eglot-pep723-has-metadata-p my-pep723-test-script)
      (princ "PASS\n")
    (princ "FAIL\n")
    (kill-emacs 1))

  ;; Test 2: Detection without metadata
  (princ "Test 2: Detection (without metadata)... ")
  (let ((regular-py (make-temp-file "test" nil ".py" "print('hello')\n")))
    (unwind-protect
        (if (not (eglot-pep723-has-metadata-p regular-py))
            (princ "PASS\n")
          (princ "FAIL\n")
          (kill-emacs 1))
      (delete-file regular-py)))

  ;; Test 3: Incomplete metadata block
  (princ "Test 3: Detection (incomplete block)... ")
  (let ((incomplete-py (make-temp-file "test" nil ".py" "# /// script\n# no closing\n")))
    (unwind-protect
        (if (not (eglot-pep723-has-metadata-p incomplete-py))
            (princ "PASS\n")
          (princ "FAIL\n")
          (kill-emacs 1))
      (delete-file incomplete-py)))

  ;; Test 4: uv python find (informational - may not have env synced)
  (princ "Test 4: uv python find... ")
  (if (not (executable-find "uv"))
      (princ "SKIP (uv not found)\n")
    (let ((python-path (eglot-pep723-get-python-path my-pep723-test-script)))
      (cond
       ((null python-path)
        (princ "WARN (no path returned)\n"))
       ((file-exists-p python-path)
        (princ (format "PASS (%s)\n" python-path)))
       (t
        (princ (format "WARN (path doesn't exist: %s)\n" python-path))))))

  ;; Test 5: Workspace configuration for ty
  (princ "Test 5: Workspace config (ty)... ")
  (let ((eglot-pep723-lsp-server 'ty)
        (config (eglot-pep723--workspace-configuration "/path/to/python" "/path/to/dir/")))
    (if (plist-get config :ty)
        (princ "PASS\n")
      (princ "FAIL\n")
      (kill-emacs 1)))

  ;; Test 6: Workspace configuration for basedpyright
  (princ "Test 6: Workspace config (basedpyright)... ")
  (let ((eglot-pep723-lsp-server 'basedpyright)
        (config (eglot-pep723--workspace-configuration "/path/to/python" "/path/to/dir/")))
    (if (plist-get config :python)
        (princ "PASS\n")
      (princ "FAIL\n")
      (kill-emacs 1)))

  (princ "\nAll tests passed.\n"))

(my-pep723-run-tests)
```

---

## Files to Modify

### `init/shared-init.el`

Add after the Python section (around line 1656, after `eglot-ensure` hook):

```elisp
;; PEP-723 inline script metadata support
(autoload #'eglot-pep723-setup "eglot-pep723")
(autoload #'eglot-pep723-sync-environment "eglot-pep723"
  "Sync PEP-723 environment and restart Eglot." t)
(autoload #'eglot-pep723-run-script "eglot-pep723"
  "Run current file as PEP-723 script." t)
(with-eval-after-load "eglot"
  (eglot-pep723-setup))
```

---

## Dev Loop Commands

### Run tests

```bash
emacs -Q --batch -l elisp/eglot-pep723.el -l tmp/pep723-test.el
```

### Check parentheses in library

```bash
emacs -Q --batch --eval '(progn (with-temp-buffer (insert-file-contents "elisp/eglot-pep723.el") (check-parens)))'
```

### Check parentheses in shared-init.el

```bash
emacs -Q --batch --eval '(progn (with-temp-buffer (insert-file-contents "init/shared-init.el") (check-parens)))'
```

### Interactive testing

1. Open `tmp/pep723-example.py` in Emacs
2. Check if warning appears (environment not synced)
3. Run `M-x eglot-pep723-sync-environment`
4. Verify Eglot restarts and connects properly
5. Test completion for `requests.` to verify LSP sees dependencies

---

## Implementation Notes

### Detection Logic

Scan first 2KB of file for:

1. Line matching `^# /// script$`
2. Followed eventually by `^# ///$`

### Warning Behavior

When `uv python find --script` returns:

- Empty/error: Warning that uv couldn't find Python
- System Python (not in `~/.cache/uv/environments`): Warning that deps not
  synced
- Environment Python: No warning, return path

Always return whatever Python path is available so LSP can provide basic
functionality.

### Hook Ordering

The `eglot-pep723--maybe-setup` hook is added to `python-mode-hook` and
`python-ts-mode-hook` without a specific depth. Since `eglot-pep723-setup` is
called in `with-eval-after-load "eglot"`, and the user's `eglot-ensure` hook is
also typically added there or in mode hooks, the PEP-723 setup should run first
because hooks run in reverse order of addition (LIFO).

If ordering becomes an issue, the hooks can be added with a negative depth
argument.

### Project Detection

The `eglot-pep723--project-find` function checks:

1. Is there a current `buffer-file-name`?
2. Does it end in `.py`?
3. Does it have PEP-723 metadata?

If all true, return `(pep723-script . "/path/to/script/dir/")`.

This is added to `project-find-functions` so it takes precedence for PEP-723
scripts.

---

## Summary

| File                    | Action | Approx Lines |
| ----------------------- | ------ | ------------ |
| `elisp/eglot-pep723.el` | Create | ~150         |
| `init/shared-init.el`   | Modify | +7           |
| `tmp/pep723-example.py` | Create | ~15          |
| `tmp/pep723-test.el`    | Create | ~60          |
